<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TextBox1.Text" xml:space="preserve">
    <value>Copyright (c) rollrat. 2015. All rights reserved.

이 프로그램은 파일안에 포함된 텍스트를 검색하기 위한 프로그램입니다.

가. 파일 검색방법
   1. 'New DB'버튼을 눌러 검색하고자하는 파일을 선택합니다.
   2. 'Open'버튼을 눌러 /db폴더에 있는 해당 db파일을 선택합니다(해당 db파일은 암호화되어있을 수 있습니다.)
   3. "Text : "에 검색하고자하는 텍스트를 입력합니다.
   4. 'Start'버튼으로 검색을 시작합니다.

나. 파일 검색결과
   파일의 검색결과는 /db폴더에 해당 db의 이름으로 .txt파일로 저장되어있습니다.
   이 파일은 주소, 줄+내용, 총 줄수가 차례로 나타나며, 마지막엔 해당 db의 정보와
   총 검색결과가 포함되어있습니다.

다. 검색 옵션
   Ignore : 대/소문자를 구분하지 않고 검색합니다.
   Regex : 정규표현식을 사용하여 검색합니다.
   Only Lines : 검색결과에 내용만을 나열합니다.

라. 부가 기능
   View DB(DB Viewer) : 해당 DB의 내용을 나열합니다.
       1. 'Export'버튼으로 해당 DB의 내용을 내보낼 수 있습니다.
       2. 옵션 'FileNames Only'는 주소에서 파일이름만 추출하여 내보냅니다.
       3. 키보드의 'F2'키를 눌러 폴더만 나열할 수 있습니다.
       4. 또한 키보드의 'F3'키를 눌러 INDEX를 나열할 수 있습니다.

   Grep Result : 검색결과의 상세정보를 표시합니다.
       검색 중에 어떤 내용이 검색되었는지 알아보려면 검색결과가 나열된 리스트에서
       원하는 내용을 더블 클릭하면 이 창을 띄울 수 있습니다.
       1. 'Run File'버튼으로 이 파일을 실행할 수 있습니다.

   Set Extension : 키보드의 'F7'키로 이 창을 띄울 수 있습니다.
       1. 리스트의 내용 중 선택한 부분을 키보드의 'Delete'키로 지울 수 있습니다.
       2. 'Add'버튼으로 확장자를 새로 추가시킬 수 있습니다. 이때, 확장자는 첫글자에
          '.'을 포함하여야 합니다.
       3. 'Default'버튼은 초기상태로 초기화합니다.
       4. 'Save'버튼은 설정내용을 저장합니다. 새로 저장된 설정내용으로 검색하려면
          프로그램을 재시작해야합니다.
       ※ 비정규 확장모드
           이 모드는 확장자대신 파일이름을 검사합니다.
           /add &lt;type&gt;&lt;PartsOfFileName&gt;를 입력합니다.
           이 모드 실행시 Main창에서 키보드의 'F9'를 눌러 NotAllowSyntax를 활성화
           시켜야합니다. 
           1. &lt;type&gt;은 '^', '$', '%'가 올 수 있으며 각각 
              파일 처음과 일치(확장자포함X), 파일 끝과 일치(확장자포함X), 파일에 포함됨(확장자포함O)
              를 의미합니다.
           2. &lt;PartsOfFileName&gt;에는 검색할 파일 이름의 일부를 입력합니다.

   Text Designer : 메인창과 'Report'창에서 키보드의 'F3'키로 이 창을 띄울 수 있습니다.
       1. 'Sort' : 텍스트창에 입력된 텍스트를 오름차순으로 정렬합니다.
       2. 'Duplicate Delete' : 텍스트창에 입련된 텍스트 중 중복되는 항목을 삭제합니다.
       3. 'Copy Cliboard' : 텍스트창에 텍스트를 클립보드에 복사합니다.
       4. 'Save' : 텍스트창에 텍스트를 다른 이름으로 저장합니다.

   Folder Mode : 키보드의 'F4'키로 이 창을 띄울 수 있습니다.
       이 창은 관리자모드가 아닌 상태에서만 사용가능합니다.
       이 기능을 이용하면 폴더들의 리스트를 가져올 수 있습니다.
       1. 나열하고자 하는 폴더를 끌어서 리스트에 드래그 &amp; 드롭합니다.
       2. '폴더 목록 작성'버튼을 이용하여 나열된 폴더의 이름들을 나열할 수 있습니다.

   Report : 'Folder Mode'에서 '폴더 목록 작성'버튼으로 이 창을 띄울 수 있습니다.
       키보드의 'F3'키로 'Text Designer'를 띄울 수 있습니다.

   Simplex Checker : 키보드의 'F5'키로 이 창을 띄울 수 있습니다.
       DB파일의 손상여부와 기타 파일들의 해쉬값을 알아보기 위해 이 기능을 사용할 수 있습니다.
       1. 'Open'버튼으로 해쉬값을 알고자하는 파일을 선택합니다.
       2. 'Show'버튼으로 해당 파일의 해쉬값을 가져옵니다. 단, 파일이 아닌 텍스트의 경우
          해당 텍스트의 해쉬값을 가져옵니다.

   File Security : 키보드의 'F6'키로 이 창을 띄울 수 있습니다.
       이 기능을 이용하면 비밀번호를 이용한 간단한 파일 암호화, 복호화 기능을 사용할 수 있습니다.
       이 버전에선 SHA-512를 이용해 키를 생성하고, AES-256 CBC로 파일을 암호화합니다.
       1. 'Open'버튼으로 암호화또는 복호화 하고자하는 파일을 불러옵니다.
       2. 'Save'로 결과파일을 생성할 곳을 선택합니다.
       3. "Password : "에 암호화, 복호화 키를 입력하고 다음 두 사항 중 하나를 시행합니다.
       4-1. 'Encryption'버튼으로 해당 파일의 암호화 파일을 생성합니다. 이때 기본 타깃파일
          확장자는 '.fsm'입니다.
       4-2. 'Decryption'버튼으로 암호화된 파일을 복호화합니다.

마. 기타 기능
   'F8'키를 눌러 'New DB'시 설정된 확장자을 가진 파일만 추출합니다.
   'F2'키를 눌러 작업을 정지할 수 있습니다.

바. 오류 처리
   /tmp와 tmp파일에 관한 오류 : 
       이 오류는 db파일을 unzip하는 도중 생성되는 파일의 잔해물이 프로그램에 의해 삭제되지
       않을 때 발생됩니다. 프로그램이 있는 폴더의 tmp폴더를 지워주세요.
   복호화시 생성되는 오류 :
       대부분 패딩에 관한 오류가 발생할 텐데, 이는 해당 비밀번호가 암호화된 파일과 맞지 않을 때
       발생됩니다.
   데이터베이스가 너무 커서 열 수 없습니다. : 
       unzip후의 db파일이 허용된 메모리보다 많은 양을 차지하면 발생됩니다.
       db를 분할 추출하여 재시도하거나, x64모드로 프로그램을 실행하세요.
   Drag &amp; Drop이 작동되지 않습니다. :
       프로그램이 최고자격증명에서 실행된 경우 이 기능을 사용할 수 없습니다.
       프로그램의 UAC를 해제하거나 자격증명을 한 단계 낮추고 다시시도하십시오.

※ DB파일에는 중요한 파일의 목록이 포함되어있을 수 있으니 보관에 유의하시기 바랍니다.</value>
  </data>
</root>